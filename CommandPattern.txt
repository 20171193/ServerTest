*커맨드 패턴
 : 실행할 기능(요청)을 객체로 캡슐화하여, 호출자와 실행자를 분리하는 패턴
 : 관심사 분리, 유연한 확장성 -> OCP 만족

 ------

 예시 1: 식당 비유
1. 손님이 웨이터에게 "주문지"를 전달한다.
2. 웨이터는 주문지를 요리사에게 전달한다.
3. 웨이터는 요리사 내부 구현을 몰라도 되고, 주문지만 전달하면 됨.
 이 "주문지"를 바로 "Command 객체"라고 볼 수 있음.
 
예시 2: 버튼 동작 분리
- 다양한 버튼: SaveButton, OpenButton, CancelButton...
- Button이 직접 동작을 가지고 있으면 → OCP 위반 발생
- 새로운 기능 추가하려면 Button 자체를 수정해야 하니까

네트워크 환경 비유
- 여러 스레드가 동시에 공유 자원에 접근하려고 할 때, 
  한 스레드가 자원을 점유하고 락을 걸면, 
  다른 스레드들은 해당 락이 해제되기를 기다리며 블로킹된다.
- 이런 구조에서는 병목현상이 발생할 수 있다.
- 커맨드 패턴을 적용하면,
  요청 자체를 Command 객체로 캡슐화해 *큐(queue)* 에 넣어두고,
  전용 스레드나 핸들러가 순차적으로 처리하게 만들 수 있다.
   -> 즉, "요청을 즉시 처리"하는 방식에서 "요청을 관리하고 처리하는 구조"로 전환된다.
   -> 결과적으로 비동기 처리, 큐잉, 병렬성 분리, OCP 만족이라는 이점을 얻는다.